from argparse import ArgumentParser
from tempfile import TemporaryFile
import os

# -------- Argument Parsing ------------------------------------------

parser = ArgumentParser(description="Using the .tsv file generated by Stacks' export function, generate individual sequences in fasta files.")
parser.add_argument("infile",
                    help = ".tsv containing SNP and sequence info.",
                    type = str)
parser.add_argument("outdir",
                    help = "Path to directory in which fasta files will be stored.",
                    nargs = '?',
                    type = str)
parser.add_argument("--filter",
                    help = "A list of loci separated by commas, return only sequences for those loci",
                    type = str)
parser.add_argument("--alleles",
                    help = "Should the output sequences be biallelic or monoallelic?",
                    type = int,
                    default = 1,
                    choices = [1,2])
parser.add_argument("--snp",
                    action = "store_true",
                    help = "Instead of returning the sequence for each locus, return a sequence consisting only of SNPs.")
args = parser.parse_args()

# -------- Check or process arguments --------------------------------
if args.outdir:
    if not args.outdir.endswith('/'):
        args.outdir += "/"
    if not os.path.isdir(args.outdir):
        exit("\nOutput directory doesn't exist.\n")
else:
    args.outdir = ""

# -------- Function definitions --------------------------------------

# Get the indices of relevant columns
def getNamesAndAttributes(f):
    # Make a list out of the file header
    l = f.readline().strip('\n').split('\t')
    # Get positions for attributes
    loc = l.index("# Catalog ID")
    pos = l.index("Deleveraged")+1
    snp = l.index("SNPs")
    seq = l.index("Consensus Sequence")
    # Return values and names
    return l[pos:], loc, seq, snp, pos

# Return a list of chars as str
def stringify(charlist):
    return "".join(charlist)

# Return a str as list of chars
def listify(string):
    return [ a for a in string ]

# Return SNPs for a locus as a list of pairs
# (for both alleles)
def getMutPairs(muts):
    if not muts:
        return ''
    if '/' not in muts:
        muts = muts + '/' + muts
    muts = muts.split('/')
    return mutPairs(muts[0],muts[1])

def mutPairs(a,b):
    return [ a[i] + b[i] for i in range(len(a)) ]
    
# Mutate the sequence when returning monoallelic pseudogenomes    
def mutSeqMono(seq, muts, position):
    # Positions might be strings; try to fix that
    try:
        position = [ int(pos) for pos in position ]
    except ValueError:
        # Might not have any mutations
        return "".join(seq)
    if not muts:
        return "N"*len(seq)
    # Introduce the SNPs
    for (mut, pos) in zip(muts, position):
        seq[pos] = ambiguity[mut]
    return "".join(seq)

# Mutate the sequence for biallelic pseudogenomes
def mutSeqBi(seq, muts, position):
    try:
        position = [ int(pos) for pos in position ]
    except ValueError:
        return "".join(seq)
    n = len(seq)/2
    if not muts:
        return "N"*2*n
    for (mut, pos) in zip(muts, position):
        seq[pos] = mut[0]
        seq[pos+n] = mut[1]
    return "".join(seq)

# Use N if SNP info is missing
def fillMissingSnps(maxSnps, muts):
    if not muts:
        return [ "NN" for i in range(maxSnps) ]
    return muts

def fastaHeader(words):
    return ">" + " | ".join(words) + "\n"

# Dictionary of IUPAC ambiguity codes
ambiguity = {"AA": "A",
             "CC": "C",
             "TT": "T",
             "GG": "G",
             "AC": "M",
             "CA": "M",
             "AG": "R",
             "GA": "R",
             "AT": "W",
             "TA": "W",
             "GC": "S",
             "CG": "S",
             "CT": "Y",
             "TC": "Y",
             "GT": "K",
             "TG": "K",
             "NN": "N"}

# -------- MAIN / TESTING --------------------------------------------
try:
    f = open(args.infile,'r')
except IOError:
    exit("Input file, " + args.infile + ", could not be opened.")

if args.filter:
    filter  = open(args.filter, 'r')
    locilist = filter.readline().strip().split(',')

names, loc, seq, snp, pos = getNamesAndAttributes(f)

# Create filenames and file handles for output files
outfiles = [ args.outdir + name + ".fasta" for name in names ]
o = [ open(out,'w') for out in outfiles ]
# Write the header in each file
if args.snp:
    for out,name in zip(o,names):
        out.write(fastaHeader([name]))
    if args.alleles == 2:
        tmp = TemporaryFile()

for line in f:
    # Get Info
    line = line.strip('\n').split('\t')
    locus = line[loc]
    # Skip line if locus isn't whitelisted
    if (args.filter) and (locus not in locilist):
        continue
    # Get a list of SNP positions
    positions = line[snp].split(';')
    positions = [ p.strip("ATCG>,") for p in positions ]
    # Get list of mutations, format them for future use
    mutations = [ getMutPairs(mut) for mut in line[pos:] ]
    # Get the sequence as a list of characters
    consensus = listify(line[seq])
    if args.snp:
        max_snps = max([len(muts) for muts in mutations])
        mutations = [ fillMissingSnps(max_snps,muts) for muts in mutations ]
        if args.alleles == 1:
            for muts,out in zip(mutations,o):
                for mut in muts:
                    out.write(ambiguity[mut])
        if args.alleles == 2:
            for muts,out in zip(mutations,o):
                for mut in muts:
                    out.write(mut[0])
                    tmp.write(mut[1])
                tmp.write("\t")
            tmp.write("\n")     
        continue
    if args.alleles == 2:
        consensus.extend(consensus)
    # Mutate sequences and write onto fasta files
    for i in range(len(names)):
        o[i].write(fastaHeader([names[i],locus]))
        if args.alleles == 1:
            o[i].write(mutSeqMono(consensus,mutations[i],positions)+"\n")
        elif args.alleles == 2:
            o[i].write(mutSeqBi(consensus,mutations[i],positions)+"\n")

# Write the second allele from the temporary file onto
# the appropriate fasta files
if args.alleles == 2 and args.snp:
    tmp.seek(0,0)
    for line in tmp:
        line = line.strip().split()
        for snp,out in zip(line,o):
            out.write(snp)
    tmp.close()

# Close all files
f.close()
for out in o:
    out.close()
